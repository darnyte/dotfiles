#!/usr/bin/env bash

# List available skeletons
list()
{
	local SKELETON
	for SKELETON in ${SKELETONS}/*
	do
		[ -d "$SKELETON" ] || continue
		echo ${SKELETON##*/}
	done
}

# Create a new project from a skeleton
#
# @param 1 - skeleton name
# @param 2 - name of new project
new()
{
	(( $# < 2 )) && return 1

	cp -ri "$SKELETONS/$1" "$2" || return $?

	# preserve working directory when sourced
	(
		cd "$2" || return $?

		local INIT=${BASH_SOURCE##*/}.sh
		if [ -f "$INIT" ]
		then
			bash "$INIT" || return $?
			rm -f "$INIT"
		fi
	)
}

# Create initialization script
init()
{
	cat << EOF > ${BASH_SOURCE##*/}.sh
#!/usr/bin/env bash
# Run this script to initialize the template or use skel to do it for you:
# https://gist.github.com/markusfisch/5e73a372241231a3a7c8

# Refactor in file contents and file/directory names
#
# @param 1 - case-sensitive pattern to replace
# @param 2 - replacement string
# @param 3 - working directory (optional)
refactor()
{
	local PATTERN=\$1
	local REPLACEMENT=\$2
	local DIR=\${3:-.}

	(( \$# < 2 )) && return 1

	# rename directories before files
	local TYPE N
	for TYPE in d f
	do
		find "\$DIR" -type \$TYPE -name "*\$PATTERN*" | while read
		do
			mv "\$REPLY" "\${REPLY//\$PATTERN/\$REPLACEMENT}"
		done
	done

	local BASH_SOURCE_FILE=\${BASH_SOURCE##*/}
	local TMP=".tmp-\$BASH_SOURCE_FILE-$$"
	grep -rl "\$PATTERN" "\$DIR"/* | while read
	do
		[ \${REPLY##*/} == \$BASH_SOURCE_FILE ] && continue

		sed -e "s/\$PATTERN/\$REPLACEMENT/g" < "\$REPLY" > \$TMP &&
			cat \$TMP > "\$REPLY"

		rm -f \$TMP
	done
}

#refactor 'AppName' "\${PWD##*/}"
EOF
}

# Add a new skeleton from a git repository
#
# @param 1 - repository
# @param 2 - skeleton name, when deviating (optional)
add()
{
	(( $# < 1 )) && return 1

	[ -d "$SKELETONS" ] || mkdir -p "$SKELETONS" || return $?

	# preserve working directory when sourced
	(
		cd "$SKELETONS" &&
			git clone $@ &&
			init
	)
}

# Print help
#
# @param ... - name of a command (optional)
help()
{
	cat << EOF
            ___
          ´     \`             ___
          ( ) ( )           ´     \`
          \`.(").´           ( ) ( )
           |===|            \`.(").´
           \`---´             |===|
             o               \`---´
       _--.--o--.--_            o
      ()\.-- o --./()     _--.--o--.--_
      |  .-- o --.  |    ()\.-- o --./()
      |  .-- o --.  |    |  .-- o --.  |

usage: ${BASH_SOURCE##*/} COMMAND [ARGUMENT...]

COMMAND may be one of:

EOF

	local DESC=

	while read
	do
		case $REPLY in
			''|refactor*)
				DESC=
				;;
			\#\ *)
				[ "$DESC" ] && continue
				DESC=${REPLY#*#}
				;;
			*\(\))
				[ "$DESC" ] || continue
				echo ${REPLY%(*} '-' $DESC
				DESC=
				;;
		esac
	done < $BASH_SOURCE
}

readonly SKELETONS=${SKELETONS:-$HOME/src/${BASH_SOURCE##*/}}

if [ "$BASH_SOURCE" == "$0" ]
then
	${@:-help}
fi
